\input{preamble.tex}
\input{environments.tex}
\input{definitions.tex}
\usepackage{tikz}
\usetikzlibrary{math}
\tikzmath{%
    \pegone = 0.0;
    \pegtwo = 10.0;
    \pegthree = 20.0;
}
\definecolor{plotblue}{HTML}{045275}
\definecolor{plotteal}{HTML}{089099}
\definecolor{plotgreen}{HTML}{7ccba2}
\definecolor{plotyellow}{HTML}{ffc61e}  % fcde9c % ffc61e  % b8860b
\definecolor{plotorange}{HTML}{f0746e}
\definecolor{plotred}{HTML}{dc3977}
\definecolor{plotpurple}{HTML}{7c1d6f}

\begin{document}
\begin{center}
    \textsc{\huge Problem Set 6}\\
    \textsc{Discrete Mathematics}\\
    \color{gruvred}{Due: $27$\textsuperscript{th} of March, $2023$}
\end{center}

\begin{enumerate}
    \item
        Suppose that we are given a sorted list $L$ of length $n \in \N$
        and we are asked to determine
        whether or not $\pn*{\exists i \in n}\pn*{L(i) = x}$.
        The \emph{binary search} algorithm solves this problem by comparing the middle element $L\pn*{\sfrac{n}{2}}$ of the list to $x$ and either returning immediately (if they are equal)
        or recursively searching the appropriate sublist (if they are unequal).
        \begin{enumerate}
            \item
                Provide a \emph{recursive} implementation in \texttt{Python} of \emph{binary search}.
                Name your function \texttt{ps06pr1a}.
                \begin{itemize}
                    \item[$\cdot$]
                        \textbf{Input:}
                        a list $L: n \to \Z$ and an integer $x \in \Z$.
                    \item[$\cdot$]
                        \textbf{Output:}
                        \texttt{True} if $\pn*{\exists i}\pn*{L(i) = x}$; \texttt{False} otherwise.
                    \item[$\cdot$]
                        \textbf{Constraints:}
                        if \texttt{len($L$) == 0}, your function should make $0$ comparisons;
                        if \texttt{len($L$) == 1}, your function should make $1$ comparison;
                        otherwise, your function should make $2$ comparisons.
                \end{itemize}
            \item
                Find a recurrence relation for the number of \emph{comparisons} your function makes.
            \item
                Prove that your recurrence relation has the closed form $T(n) = 2\log_2(n) + 1$.
        \end{enumerate}
    \item
        In this problem,
        we want an efficient way of recursively \emph{merging} two sorted lists into one sorted list.
        \begin{enumerate}
            \item
                Provide a \emph{recursive} implementation in \texttt{Python} of \emph{merge}.
                Name your function \texttt{ps06pr2a}.
                \begin{itemize}
                    \item[$\cdot$]
                        \textbf{Input:}
                        a sorted list $L_1: n_1 \to \Z$ and a sorted list $L_2: n_2 \to \Z$.
                    \item[$\cdot$]
                        \textbf{Output:}
                        a sorted list $L: (n_1 + n_2) \to \Z$ containing all of the elements of $L_1$ and $L_2$.
                    \item[$\cdot$]
                        \textbf{Constraints:}
                        if the length of either input list is $0$, your function can return immediately;
                        otherwise, your function should make $1$ comparison.
                \end{itemize}
            \item
                Find a recurrence relation for the number of \emph{comparisons} your function makes.\\
                \emph{Hint:} your recurrence should be a function of \emph{one} variable,
                which is the \emph{size of the problem}.
            \item
                Prove that your recurrence relation has the closed form $T(n) = n$.
        \end{enumerate}
    \item
        The towers of Hanoi are an arrangement of three wooden pegs,
        labelled \emph{start}, \emph{middle}, and \emph{end},
        along with a collection of $n$ rings of distinct sizes.
        The rings are all stacked on the \emph{start} peg in ascending order based on their sizes.
        The goal is to move all of the rings from the \emph{start} peg to the \emph{end} peg
        without violating the following constraints:
        \begin{itemize}
            \item[$\cdot$]
                A \emph{move} consists of moving the top-most ring from one peg
                to the top of the stack on another peg.
            \item[$\cdot$]
                A larger ring can never be stacked on top of a smaller ring.
            \item[$\cdot$]
                Rings can only be moved one-at-a-time.
        \end{itemize}
        The question is: what is the minimum number of moves required to win the game with $n \in \N_+$ rings?
        \begin{figure}[H]
            \centering
            \begin{subfigure}{0.25\linewidth}
                \centering
                \begin{tikzpicture}[scale=0.1]
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegone,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegone,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotpurple,fill=plotpurple] (1 + \pegone,1.5) rectangle ++(7.0,1.0);
                    \draw[draw=plotblue,fill=plotblue] (2 + \pegone,3) rectangle ++(5.0,1.0);
                    \draw[draw=plotteal,fill=plotteal] (3 + \pegone,4.5) rectangle ++(3.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegtwo,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegtwo,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegthree,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegthree,0.0) rectangle ++(1.0,8.0);
                \end{tikzpicture}
                \caption{Initial configuration.}
            \end{subfigure}%
            \begin{subfigure}{0.25\linewidth}
                \centering
                \begin{tikzpicture}[scale=0.1]
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegone,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegone,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotpurple,fill=plotpurple] (1 + \pegone,1.5) rectangle ++(7.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegtwo,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegtwo,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotblue,fill=plotblue] (2 + \pegtwo,1.5) rectangle ++(5.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegthree,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegthree,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotteal,fill=plotteal] (3 + \pegthree,1.5) rectangle ++(3.0,1.0);
                \end{tikzpicture}
                \caption{After two moves.}
            \end{subfigure}%
            \begin{subfigure}{0.25\linewidth}
                \centering
                \begin{tikzpicture}[scale=0.1]
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegone,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegone,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegtwo,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegtwo,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotyellow,fill=plotyellow] (0.0 + \pegthree,0.0) rectangle ++(9.0,1.0);
                    \draw[draw=plotyellow,fill=plotyellow] (4.0 + \pegthree,0.0) rectangle ++(1.0,8.0);
                    \draw[draw=plotpurple,fill=plotpurple] (1 + \pegthree,1.5) rectangle ++(7.0,1.0);
                    \draw[draw=plotblue,fill=plotblue] (2 + \pegthree,3) rectangle ++(5.0,1.0);
                    \draw[draw=plotteal,fill=plotteal] (3 + \pegthree,4.5) rectangle ++(3.0,1.0);
                \end{tikzpicture}
                \caption{Final configuration.}
            \end{subfigure}
        \end{figure}
        \begin{enumerate}
            \item
                Provide a \emph{recursive} implementation in \texttt{Python} of \emph{towers of Hanoi}.
                Name your function \texttt{ps06pr3a}.
                \begin{itemize}
                    \item[$\cdot$]
                        \textbf{Input:}
                        a positive natural number $n \in \N_+$ representing the number of rings.
                    \item[$\cdot$]
                        \textbf{Output:}
                        a number $n \in \N_+$ denoting the minimum number of moves required to win the game.
                    \item[$\cdot$]
                        \textbf{Constraints:}
                        none.
                \end{itemize}
            \item
                Find a recurrence relation for the
                \emph{minimum number of moves required to win the game} with $n$ rings.
            \item
                Prove that your recurrence relation has the closed form $T(n) = 2^n - 1$.\\
                \emph{Hint:} recall that $\sum_{i = 0}^{n}2^i = 2^{n + 1} - 1$ for all $n \in \N$.
        \end{enumerate}
\end{enumerate}

\begin{remark}
    Formally, a \emph{list} of length $n \in \N$ with elements from $A$ is just a function $L: n \to A$.
    The $k\textsuperscript{th}$ term in the list is given by $L(k)$ for $k \in \set*{0, \dots n - 1}$,
    so this corresponds to $0$-indexed arrays when programming.
\end{remark}

\textbf{Code Submission Instructions:}
\begin{quote}
    \vspace{-\parskip}
    Several of the problems in this problem set have a programming component.
    The \texttt{Python} functions you define
    must be named as the instructions for each problem indicate,
    and they \emph{must be recursive}.
    You are not permitted to use any internal or external libraries
    (\ie no \texttt{import <...>} statements).
    Your functions should all be implemented in one file,
    with the filename \texttt{ps06-<lastname>-<firstname>.py};
    for example, a possible file name would be \texttt{ps06-gonzalez-cedre-daniel.py}.

    If you are submitting the rest of your solutions to this problem set electronically,
    then attach your \texttt{Python} file \emph{in the same email}
    as the rest of your solutions.

    If you are submitting your proofs in-person on paper, then email your code separately.
\end{quote}
\end{document}
