\input{preamble.tex}
\input{environments.tex}
\input{definitions.tex}

\begin{document}

\title{Discrete Mathematics}
\author{Daniel Gonzalez Cedre}
\date{University of Notre Dame \\ Spring of 2023}
\maketitle

\setcounter{chapter}{2}
\chapter{Zermelo-Fraenkel Set Theory}
\begin{quote}
    ``No one shall expel us from the paradise that Cantor has created.''
    \begin{flushright}
        ---David Hilbert
    \end{flushright}
\end{quote}

\section{The Language of Set Theory}
In order to use our first-order logic as a language with which to talk about math,
we need to specify: what is our universe of discourse \(\Omega\), and what are our fundamental predicate symbols?
% \begin{enumerate}
%     \item
%         What is our universe of discourse \(\Omega\)?
%     \item
%         What are our fundamental predicate symbols?
% \end{enumerate}
% With these two questions answered,
% we will be able to take objects from \(\Omega\) and make atomic formul{\ae} out of them,
% which we can then use to construct our {\wff}.
The analogy drawn in class between the structure of the study of mathematics
and the abstract structure of a modern computer
should hopefully communicate how natural and common the notion is of having one \emph{type} of object
that implements other, more complicated objects.
However, this decision actually goes back to the beginning of
this \(20\)\textsuperscript{th} century revolution in mathematics.
The initial solution people came up with to the fundamental logical and foundational problems they had discovered
has to use a \emph{ramified}---or \emph{typed}---ontology,
where different objects had different \emph{types} in a hierarchy and there were rules governing how objects
could be manipulated based on their \emph{type}.
The problem with this approach is that it becomes very syntactically-cumbersome for humans
(the primary practitioners of mathematics) to deal with directly,
so it was quickly abandoned for an \emph{untyped} approach.

\begin{note}
    The converse is true about the \emph{\(\lambda\)-calculus},
    which is perhaps the most famous mathematical model of computation after the Turing machine.
    Although the untyped \(\lambda\)-calculus is more expressive (\ie stronger)
    than any of the typed \(\lambda\)-calculi (and is thus more interesting to study for mathematicians),
    the modern functional programming languages we have today (\eg Haskell, the LISP dialects, F\#)
    are actually implementations of typed \(\lambda\)-calculi
    because computers have no issues dealing with the syntactic complications of a typed theory.
\end{note}

Our universe of discourse will consist of \emph{those objects that we can prove exist}
using the rules of inference and the \emph{axioms of set theory} (which we will develop in this chapter).
The axioms of set theory will be sentences in the \emph{language of Zermelo-Fraenkel set theory}
that describe \emph{what exactly sets are} and \emph{how they work}.
The language of set theory will have two predicate symbols, defined below.

\begin{definition}[Equality]\label{def:equal}
    We define the binary predicate \(=\) to mean that
    its left argument is \emph{identically the same} as its right argument.
    So, if \(x\) and \(y\) are sets, then we say \(x = y\)
    when we mean that the names \(x\) and \(y\) both refer to the same underlying object.
\end{definition}

\begin{definition}[Elementhood]\label{def:element}
    We define the binary predicate \(\in\) to mean that its left argument is
    contained in its right argument as an element.
    So, if \(x\) and \(y\) are sets, then the phrase \(x \in y\)
    conveys that \(x\) is an element of \(y\).
\end{definition}

\begin{definition}[Language of Set Theory]
    The \emph{language of Zermelo-Fraenkel set theory}
    consists of the first-order logic
    along with
    \begin{enumerate}
        \item[I.]
            a universe of discourse consisting of
            those things that provably exist from the axioms (\autoref{sec:axioms}),
        \item[II.]
            the binary predicates for equality (\(=\), \autoref{def:equal})
            and elementhood (\(\in\), \autoref{def:element}).
    \end{enumerate}
\end{definition}

\section{Axioms of Set Theory}\label{sec:axioms}

\setcounter{preaxiom}{-1}
\begin{axiom}[Existence]
    \(\exists x \pn*{x = x}\)
\end{axiom}
This axiom asserts that our universe of discourse is non-empty.
Assuming this axiom lets us know for sure that when we make claims about sets,
those claims are actually in reference to objects that provably exist
(because we can use this axiom as an assumption in any proof).

% ALGORITHM
% \begin{algorithm}[caption={placeholder}, label={alg:placeholder}]
%     input:  int list $\brackets*{x_1, \dots x_n}$ with $n \geq 2$
%     output: int list
%     begin
%         for $x$ in $\brackets*{x_1, \dots x_n}$:
%             do something
%         return result
%     end
% \end{algorithm}
\end{document}
